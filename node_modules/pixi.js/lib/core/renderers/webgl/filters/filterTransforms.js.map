{"version":3,"sources":["../../../../../src/core/renderers/webgl/filters/filterTransforms.js"],"names":["calculateScreenSpaceMatrix","calculateNormalizedScreenSpaceMatrix","calculateSpriteMatrix","outputMatrix","filterArea","textureSize","mappedMatrix","identity","translate","x","width","y","height","scale","translateScaleX","translateScaleY","sprite","texture","_texture","baseTexture","set","worldTransform","copy","TEMP_MATRIX","invert","prepend","anchor"],"mappings":";;;QAUgBA,0B,GAAAA,0B;QAeAC,oC,GAAAA,oC;QAeAC,qB,GAAAA,qB;;AAxChB;;AAEA;;;;;;AAMA;AACA;AACO,SAASF,0BAAT,CAAoCG,YAApC,EAAkDC,UAAlD,EAA8DC,WAA9D,EACP;AACK;AACD;;AAEA;AACA,QAAMC,eAAeH,aAAaI,QAAb,EAArB;;AAEAD,iBAAaE,SAAb,CAAuBJ,WAAWK,CAAX,GAAeJ,YAAYK,KAAlD,EAAyDN,WAAWO,CAAX,GAAeN,YAAYO,MAApF;;AAEAN,iBAAaO,KAAb,CAAmBR,YAAYK,KAA/B,EAAsCL,YAAYO,MAAlD;;AAEA,WAAON,YAAP;AACH;;AAEM,SAASL,oCAAT,CAA8CE,YAA9C,EAA4DC,UAA5D,EAAwEC,WAAxE,EACP;AACI,QAAMC,eAAeH,aAAaI,QAAb,EAArB;;AAEAD,iBAAaE,SAAb,CAAuBJ,WAAWK,CAAX,GAAeJ,YAAYK,KAAlD,EAAyDN,WAAWO,CAAX,GAAeN,YAAYO,MAApF;;AAEA,QAAME,kBAAmBT,YAAYK,KAAZ,GAAoBN,WAAWM,KAAxD;AACA,QAAMK,kBAAmBV,YAAYO,MAAZ,GAAqBR,WAAWQ,MAAzD;;AAEAN,iBAAaO,KAAb,CAAmBC,eAAnB,EAAoCC,eAApC;;AAEA,WAAOT,YAAP;AACH;;AAED;AACO,SAASJ,qBAAT,CAA+BC,YAA/B,EAA6CC,UAA7C,EAAyDC,WAAzD,EAAsEW,MAAtE,EACP;AACI,QAAMC,UAAUD,OAAOE,QAAP,CAAgBC,WAAhC;AACA,QAAMb,eAAeH,aAAaiB,GAAb,CAAiBf,YAAYK,KAA7B,EAAoC,CAApC,EAAuC,CAAvC,EAA0CL,YAAYO,MAAtD,EAA8DR,WAAWK,CAAzE,EAA4EL,WAAWO,CAAvF,CAArB;AACA,QAAMU,iBAAiBL,OAAOK,cAAP,CAAsBC,IAAtB,CAA2B,aAAOC,WAAlC,CAAvB;;AAEAF,mBAAeG,MAAf;AACAlB,iBAAamB,OAAb,CAAqBJ,cAArB;AACAf,iBAAaO,KAAb,CAAmB,MAAMI,QAAQP,KAAjC,EAAwC,MAAMO,QAAQL,MAAtD;AACAN,iBAAaE,SAAb,CAAuBQ,OAAOU,MAAP,CAAcjB,CAArC,EAAwCO,OAAOU,MAAP,CAAcf,CAAtD;;AAEA,WAAOL,YAAP;AACH","file":"filterTransforms.js","sourcesContent":["import { Matrix } from '../../../math';\n\n/**\n * Calculates the mapped matrix\n * @param filterArea {Rectangle} The filter area\n * @param sprite {Sprite} the target sprite\n * @param outputMatrix {Matrix} @alvin\n */\n// TODO playing around here.. this is temporary - (will end up in the shader)\n// this returns a matrix that will normalise map filter cords in the filter to screen space\nexport function calculateScreenSpaceMatrix(outputMatrix, filterArea, textureSize)\n{\n     // let worldTransform = sprite.worldTransform.copy(Matrix.TEMP_MATRIX),\n    // let texture = {width:1136, height:700};//sprite._texture.baseTexture;\n\n    // TODO unwrap?\n    const mappedMatrix = outputMatrix.identity();\n\n    mappedMatrix.translate(filterArea.x / textureSize.width, filterArea.y / textureSize.height);\n\n    mappedMatrix.scale(textureSize.width, textureSize.height);\n\n    return mappedMatrix;\n}\n\nexport function calculateNormalizedScreenSpaceMatrix(outputMatrix, filterArea, textureSize)\n{\n    const mappedMatrix = outputMatrix.identity();\n\n    mappedMatrix.translate(filterArea.x / textureSize.width, filterArea.y / textureSize.height);\n\n    const translateScaleX = (textureSize.width / filterArea.width);\n    const translateScaleY = (textureSize.height / filterArea.height);\n\n    mappedMatrix.scale(translateScaleX, translateScaleY);\n\n    return mappedMatrix;\n}\n\n// this will map the filter coord so that a texture can be used based on the transform of a sprite\nexport function calculateSpriteMatrix(outputMatrix, filterArea, textureSize, sprite)\n{\n    const texture = sprite._texture.baseTexture;\n    const mappedMatrix = outputMatrix.set(textureSize.width, 0, 0, textureSize.height, filterArea.x, filterArea.y);\n    const worldTransform = sprite.worldTransform.copy(Matrix.TEMP_MATRIX);\n\n    worldTransform.invert();\n    mappedMatrix.prepend(worldTransform);\n    mappedMatrix.scale(1.0 / texture.width, 1.0 / texture.height);\n    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n\n    return mappedMatrix;\n}\n"]}